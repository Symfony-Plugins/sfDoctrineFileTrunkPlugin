<?php

/**
 * PluginFileTrunk
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id$
 */
abstract class PluginFileTrunk extends BaseFileTrunk
{
  protected $img_types = array(
    'image/jpeg',
    'image/pjpeg',
    'image/png',
    'image/gif',
	);
  
  public static function getPath()
	{
		return sfConfig::get('sf_upload_dir');
	}
  
  /**
	 * Generates a thumbnail filename from the actual name
	 * 
	 * @param int $width
	 * @param int $height
	 * @param string $method
	 * @return string
	 */
	protected function generateThumbnailName($width, $height, $method = 'fit')
	{
		// prepare regular expression to construct a thumbnail filename
		// {actualname}-{width}x{height}.{method}.{extension}
		$thumb_regexp = '/([^.]*)\.(.*)?/';
		$thumb_replace = sprintf('$1-%dx%d-%s.$2', $width, $height, $method);
		
		return preg_replace($thumb_regexp, $thumb_replace, $this->getActualName());
	}
	
	/**
	 * Method to retrieve files related to the current instance
	 * 
	 * @return array An array of all related files to this file trunk object
	 */
	protected function getRelatedFiles()
	{
		// we need to first delete all files associated with the FileTrunk object
		$file_name_only = substr( $this->getActualName(), 0, strrpos( $this->getActualName(), '.' ) ) . '*';
		// since we might have thumbnails we have to find all files that begin with the actual name
		return sfFinder::type( 'file' )->name( $file_name_only )->in( self::getPath() );
	}

	/**
	 * This method generates a thumbnail if the file in the trunk is of any of the supported image mime-types
	 * 
	 * @throws Exception, InvalidArgumentException
	 * 
	 * @param int $width max width of thumbnail
	 * @param int $height max height of thumbnail
	 * @param string $method (optional)
	 * @param mixed $background (optional)
	 * @param int $quality (optional) sets the quality of the thumbnail
	 * 
	 * @return string Returns the path of the generated thumbnail
	 */
	public function generateThumbnail($width, $height, $method='fit', $background=null, $quality = 75)
	{
		// Let's first see if the mime-type is an image mime-type
		// If the mime-type is not supported we will throw an exception 
		if (!in_array($this->getMimeType(), $this->img_types))
		{
			throw new Exception(sprintf('Image MIME type %s not supported', $this->getMimeType()));
		}
		
		// Now we validate the width and the height.
		// Currently only a range from 5 to 1000 pixels (inclusive) is allowed
		// If the values are invalid we will throw an InvalidArgument
		if ($width >= 5 && $width <= 1000 && $height >= 5 && $height <= 1000)
		{
			// get our file name with path
			$filename = self::getPath().DIRECTORY_SEPARATOR.$this->getActualName();
			
			// get our thumbnail file name with path 	
			$thumb_filename = self::getPath().DIRECTORY_SEPARATOR.$this->generateThumbnailName($width, $height, $method);
			
			// Let us check first if the thumbnail already exists
			// If it doesn't exist then we will generate and save it
			if (!file_exists($thumb_filename))
			{
				// The file does not exist. For security reasons we have to check that no other thumbnail
				// From the same file has been created in the past 30 minutes. This check is disabled in the dev environment
				if (sfConfig::get('sf_environment') != 'dev')
				{
					$compare_time = strtotime('-30 minutes');
					$files = $this->getRelatedFiles();
					$original_file = self::getPath().DIRECTORY_SEPARATOR.$this->getActualName();
					foreach ($files as $file)
					{
						// if we have found a file that has been created in the past 30 minutes
						// we will return it as the thumbnail.
						if ($file != $original_file && filemtime($file) > $compare_time )
						{
							return $file;
						}
					}
				}
				
				// now we will create the thumbnail from our original file and save it
				$img = new sfImage($filename, $this->getMimeType());
				$img->thumbnail($width, $height, $method, $background);
				$img->setQuality($quality);
				$img->saveAs($thumb_filename);
				
				/*$thumb = new sfThumbnail($width, $height, $scale, $inflate, $quality);
				$thumb->loadFile($filename);
				$thumb->save($thumb_filename);*/
			}
			
			// At last we return the thumbnail filepath
			return $thumb_filename;
		}
		throw new InvalidArgumentException(sprintf('Width and height are invalid. %d and %d given respectively', $width, $height));
	}

	public function __toString()
	{
		return $this->getOriginalName();
	}
  
  /**
   * applies the changes made to this object into database
   * this method is smart enough to know if any changes are made
   * and whether to use INSERT or UPDATE statement
   *
   * this method also saves the related components
   *
   * @param Doctrine_Connection $conn     optional connection parameter
   * @throws Exception                    if record is not valid and validation is active
   * @return void
   */
  public function save(Doctrine_Connection $conn = null) {
    // First we need to check if the current object is new. Only new FileTrunk object may be saved.
		// Update of file trunk objects is not supported
		if (!$this->isNew())
		{
			throw new Doctrine_Exception('FileTrunk objects cannot be updated. Only newly created or deleted');
		}
		
		// Now we have to check if the file actually exists. If not we will throw another exception
		$filename = self::getPath() . DIRECTORY_SEPARATOR . $this->getActualName();
		if (!file_exists($filename))
		{
			throw new Doctrine_Exception('FileTrunk file could not be found. FileTrunk objects have to be created through file upload using sfValidatedFileTrunk class.');
		}
		parent::save($con);
  }

	/**
   * deletes this data access object and all the related composites
   * this operation is isolated by a transaction
   *
   * this event can be listened by the onPreDelete and onDelete listeners
   *
   * @return boolean      true if successful
   */
	public function delete(Doctrine_Connection $conn = null)
	{
		// Get all related files
		$files = $this->getRelatedFiles();

		// now we loop through all the found files and try to delete them
		foreach ( $files as $file )
		{
			@unlink( $file );
		}
		parent::delete($con);
	}
}